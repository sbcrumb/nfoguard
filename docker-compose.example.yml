# NFOGuard Production Docker Compose - 3-Container Architecture
# 
# RECOMMENDED SETUP: Separated core processing and web interface for optimal performance
# 
# This is the default configuration providing:
# - Performance isolation between web and processing
# - Webhook responsiveness during scans  
# - Independent scaling and updates
# - Professional web interface with branding
#
# For legacy single-container setup, see: docker-compose.legacy-single.yml

services:
  # PostgreSQL Database
  nfoguard-db:
    image: postgres:15-alpine
    container_name: nfoguard-db
    restart: unless-stopped
    env_file:
      - .env
      - .env.secrets
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - TZ=${TZ}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "${DB_EXTERNAL_PORT:-5432}:5432"  # Optional external access
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-nfoguard} -d ${DB_NAME:-nfoguard}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - nfoguard-network

  # NFOGuard Core (Processing Engine)
  nfoguard:
    image: sbcrumb/nfoguard:latest
    container_name: nfoguard-core
    restart: unless-stopped
    env_file:
      - .env
      - .env.secrets
    environment:
      - TZ=${TZ}
      - WEB_EXTERNAL_PORT=${WEB_EXTERNAL_PORT}
    volumes:
      # Media paths (adjust to your setup)
      - /mnt/unionfs/Media/TV:/media/TV:ro
      - /mnt/unionfs/Media/Movies:/media/Movies:ro
      # Data persistence
      - nfoguard_data:/app/data
      # Logs
      - nfoguard_logs:/app/data/logs
    ports:
      - "${CORE_API_PORT:-8080}:8080"  # Core API (webhooks, processing)
    depends_on:
      nfoguard-db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - nfoguard-network

  # NFOGuard Web Interface
  nfoguard-web:
    image: sbcrumb/nfoguard:latest  # Same image as core!
    container_name: nfoguard-web
    restart: unless-stopped
    command: ["python", "start_web.py"]  # Different entry point
    env_file:
      - .env
      - .env.secrets
    environment:
      - TZ=${TZ:-America/New_York}
    ports:
      - "${WEB_API_PORT:-8081}:8081"  # Web Interface
    depends_on:
      nfoguard-db:
        condition: service_healthy
      nfoguard:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    networks:
      - nfoguard-network

volumes:
  postgres_data:
    driver: local
  nfoguard_data:
    driver: local
  nfoguard_logs:
    driver: local

networks:
  nfoguard-network:
    driver: bridge

# Configuration Notes:
# 1. Core Processing (nfoguard): Handles webhooks, scanning, NFO management
# 2. Web Interface (nfoguard-web): Lightweight dashboard and management
# 3. Database (nfoguard-db): Shared PostgreSQL database
# 
# Port Configuration:
# - Core API: ${CORE_API_PORT:-8080} (webhooks, processing)
# - Web Interface: ${WEB_API_PORT:-8081} (dashboard)
# - Database: ${DB_EXTERNAL_PORT:-5432} (optional external access)
#
# Performance Benefits:
# - Web interface operations don't impact core processing
# - Webhooks remain responsive during long scans
# - Independent scaling and resource allocation
# - Separated concerns for maintenance and updates